CRUD - 233
DATA TYPES - 172
VARIABLES - 211
EXECTION CONTEXT (EC) - 275
FUNCTIONS - 413
OPERATORS - 752
NUMBERS - 810
TEMPLATE LITERALS ``(ES6) - 841
IF and ELSE STATEMENTS - 869
STATEMENTS and EXPRESSIONS - 971
TRUTHY and FALSY - 981
LOOPS - 1000
ARRAYS - 1290
OBJECTS - 1620
SETS - 1864
MAPS - 1900
OTHER OPERATORS - 1937
REST PATTERN - 1990
AND and OR OPERATORS - 1936
..
....
DOM - 2038
EVENT LISTENERS - 2135
STRINGS - 2200



COURSE MATERIAL: https://github.com/jonasschmedtmann/complete-javascript-course 

________________________________________________

THINGS TO REPEAT  OR  TO UNDERSTAND:


.insertAdjacentHTML          -> The insertAdjacentHTML() method inserts HTML code into a specified position......


The insertAdjacentHTML method does NOT reparse the element it is invoked on, so it does not corrupt the element.


https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML?retiredLocale=de
https://dev.to/jeannienguyen/insertadjacenthtml-vs-innerhtml-4epd


POSITIONS: (we have to choose one)
__________

'beforebegin': before the element - Only valid if the element is in the DOM tree and has a parent element.
'afterbegin': before its first child of the element.
'beforeend': after the last child of the element
'afterend': after the element

<!-- beforebegin -->
<p>
  <!-- afterbegin -->    most common
  foo
  <!-- beforeend -->    most common
</p>
<!-- afterend -->


SYNTAX:                      (the var -> for example,,, "a string of HTML (the string containing the HTML), which we want to insert."
.insertAdjacentHTML(position, variable)
.insertAdjacentHTML(position, text)  -> it depents on what we want to insert

EXAMPLE:
.insertAdjacentHTML('afterbegin', variable)

................................................

.innerHTML

innerHTML is the quickest way to modify HTML. You can use it to REPLACE the contents of an element.
HTML returns everything, including the HTML.

...............................................

.textContent
 returns the text itself

................................................

closures                    -> part of functions

.entries method  returns the index, and the value



Iterables

What are the list of iterables in JavaScript?
String , Array , TypedArray , Map and Set are all built-in iterables, because their prototype objects all have a Symbol.

-> they can be converted to real arrays -> using  Array.from()



________________________________________________


PROGRAMMING LEANGUAGE: BUILDING WEB APPLICATIONS

HTML is for         "NOUNS"               <p></p>        means  paragraph
CSS is for          "ADJECTIVES"          p {color: red} means  the paragraph is red
JAVASCRIPT is for   "VERBS"               p.hide();      means  hide the paragraph


DATA STRUCTURE OVERVIEW

          SOURCES OF DATA
          1 from the program itself: Data directly written in the source code
          2 from the UI: Data INPUT from the user, or data written in DOM
          3 from external sources: Data FETCHED for example from a web API

                                        â¬‡ï¸

                                COLLECTION of data

                                        â¬‡ï¸

                                  Data Structure 

                    SIMPLE LIST? â†™ï¸           â†˜ï¸ KEY/VALUE PAIR?

          ARRAYS or SETS                              OBJECTS or MAPS



NOTE: ALWAYS use latest google chrome for development

For using strict mode in js -> first line of code in the js file:  'use strict';


JS for FRONTEND
JS + Node.js for BACKEND 


NOTE: CALLBACK FUNCTIONS ARE ACTUALLY The MOST IMPORTANT THING TO UNDERSTAND IN JS

(lecture 131) !!!


.addEventListener()
.forEach()
-> are build-in callback ja function (they are rly important and useful)




alert();                      Showing to the client in the browser
prompt();                     Creates a popup window
console.log();                Showing to the developer
console.log(x, y, z);         Showing multiple values at ones


open console in chrome `shortcut
option + cmd + j



GOES ALWAYS into the END of the Body of the HTML File
<script></script>




SHORTENINGS
___________

let currentScore = 0;

currentScore += dice;
// currentScore = currentScore + dice;                      // line is equivalent, just longer




          STRING INTERPOLATION
          ____________________

var myName = 'Tobias';
var myCity = 'Porto';
console.log(`My name is ${myName}. My favorite city is ${myCity}.`);      // with the ``we can use ... directly
                        
My name is Tobias. My favorite city is Porto.
                        



          CLASSES
          _______
      
The body of a class is the part that is in curly brackets {}. This is where you define class members, such as methods or constructor.
!- in classes we have to use arrow function inside of a function (to refer to the overall class)

            
            
                        
          CLASSES  & >  METHODS
          _____________________     

constructor()    -> The constructor method is a special method for creating and initializing an object created with a class.
filter()         -> https://www.w3schools.com/jsref/jsref_filter.asp

In JavaScript, the filter() method allows us to filter through an array - iterating over the existing values, and returning only the ones 
that fit certain criteria, into a new array.

.querySelector() -> The Document method querySelector() returns the first Element within the document that matches the specified selector


reduce method    -> "we started with many things and REDUCED it down to one thing"

optional add start value 0



    
          THROW STATEMENTS   
          ________________
         
throw statement:         https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_state_throw_error


Example: Please input a number between 5 and 10:

                  ghjgh     ==> Test Input

                  Input not a number (NaN)


                  if(x == "")  throw "is Empty";
                      if(isNaN(x)) throw "not a number";
                      if(x > 10)   throw "too high";




          CRUD Operarations
          _________________

LETTER	OPERATION	       HTTP REQUEST                              SQL FUNCTION

C          Create          POST                                        INSERT
R          Read            GET                                        SELECT
U          Update          PATCH/PUT(if you have id or uuid)          UPDATE
D          Delete          DELETE                                        DELETE




         DATA TYPES (Values have a type, NOT the variables)
         __________

The 7 PRIMITIV DATA TYPES:  (all other things are Objects(REFERENCE TYPES)) 


String = a String of Charakters -> a string/sequence of charakters -> '' or ""
Numbers = 123
Booleon = true or false
____________________ MOST IMPORTANT DATA TYPES

4. Undefined (empty value)
5. Null (empty value)
6. Symbol (ES2015)
7. BigInt (ES2020)


-> with typeof(); -> we can find out what data type we have
-> console.log(typeof PI);
SAME -> console.log(typeof(PI));


NOTE: IF WE WANT TO CONVERT A NUMBER TO A STRING ->

const str = number + '';

-> when one of the operands of the plus sign is a string -> it will convert all the operands to a STRING



Type Conversion
_______________

Converting strings to numbers and others:

we can convert to 3 data types:

1. to number
2. to strings
3. to booleons


const inputYear = '1991';
console.log(inputYear + 18);
//       -> Number
console.log(Number(inputYear), inputYear);  // converting a string 
console.log(Number(inputYear) + 18);



TYPE COERSION
_____________

let n = '1' + 1;    // '11'   -> string
n = n - 1;
console.log(n);     //  10    -> Number




         VARIABLES 
         _________

"are like boxes with a package inside (or which hold an object inside)"

Ways to declare a Variable:

var = variable -> you can reassign a new value what is inside the keyword       // should be completelly avoided
let = modern ddeclaring of an variable -> can be reassigned in the future       // should be only used if we rly wanna reassing a value later


Example:

let test = 123;
console.log(test);  -> 123
// reassigning
test = 'successfull';
console.log(test);  -> successfull


const = constant -> can not be reassigned, its a Constant                       // should be used aas much as possible


Variables inside a function are all LOCAL
Variables outside a function are all GLOBAL


NOTE: we can assign var outside of a function (at the beginning usually), 
like this:

let currentScore, activePlayer, playing;

and the reassign them in the function ->


const init = function () {
  currentScore = 0;
  activePlayer = 0;
  playing = true; // using a state variable
};
init();                                                     ---> and then call the function -> so that the variable will be read


SYNTAX:

Keyword Name    Value          ->       we store values in variables
 â†“       â†“        â†“
var   myName = "Tobias";     


console.log(myName);           ->       shows us which value is inside the "box"


NAMING:

myVar
my_var
myVar123

123myVar -> in js var names cant start with numbers!



_ thats a throw away variable




          EXECUTION CONTEXT (EC) 91
          ______________________

after Compilation (compiling the code)
          â¬‡ï¸
The code is ready to be executed
          â¬‡ï¸
Creation of "global execution context" (for top-level code)
-> that is code, that is NOT inside a function
-> only the code that is outside of the function will be executed!
-> functions should ONLY be executed WHEN THEY ARE CALLED
-> Exactly ONE global execution context
          â¬‡ï¸
Execution of tÃ³p.level code (inside global EC)
          â¬‡ï¸
Execution of functions and waiting for callbacks
-> One EC per function: For each function call, a new EC is created


=> All these execution Contexts together, make up the CALL STACK



WHATS INSIDE OF EC?
___________________

1. Variable Environment
          contains all its local variables
          let, const and var declarations
          functions
          arguments object

2. Scope chain
3. this keyword
          



          FUNCTIONS
          _________

NOTE: Functions are a special kind of Objects
      -> So they have access to some methods and properties
      -> Call, bind, and apply are some of the methods that every function inherits


SYNTAX:
Creating a function:

FAB: function foo() {}

Keyword   Name  Parameters: -> for Input-Values
   â†“       â†“    â†“ 
function doThis( ) {
  serie of instruction
  ...
  ...
  return ???
}

-> if we call the function everything between the {  "function body"  } will be executed

CALL-ing / RUN-ning / Invoking the function:

doThis();



"Functions are like a maschines, where we put something in (parameter) and then the maschine is processing the input (data) and gives us an new output."


//       "maschine name"("ingridients") 
//        function name (parameters)
function fruitProcessor(apples, oranges) {
  console.log(apples, oranges);
  const juice = `Juice with ${apples} apples and ${oranges} oranges.`;
  return juice; // the result of executing the function
};
//                               'Arguments'
const appleJuice = fruitProcessor(5, 0);
console.log(appleJuice);
//                               'Arguments'
const orangeJuice = fruitProcessor(0, 4);
console.log(orangeJuice);

const appleOrangeJuice = fruitProcessor(4, 4);
console.log(appleOrangeJuice);



PREVENTING AN EVENT BY DEFAULT
______________________________

if we want to prevent something to happen by default

(that the site jump to the top by default if we click a button for example)

->
// to prevent the default  // e is for the event
const example = function (e) {
e.preventDefault();
}



FIRST CLASS FUNCTIONS
_____________________

- JS treats functions as FIRST-CLASS CITIZENS
- this means functions are SIMPLY VALUES !!!
- functions ARE just another "TYPE OF OBJECTS"

we can store functions in variables or properties!
pass functions as arguments to OTHER functions!
return functions FROM functions!
we have also function METHODS!



HIGHER-ORDER FUNCTIONS
______________________

They are only possible because of first class funtions!

1. A function that receives another function as an argument, 
2. that returns a new function, or both.



FUNCTIONS RETURNING FUNCTIONS
_____________________________

// becomes very useful if we use "functional programming"

const greet = function (greeting) {
  // all this function is do, is returning a new function
  return function (name) {
    console.log(`${greeting} ${name}`);
  };
};
//    This Value now, is actually a function -> its the functon behind return
const greeterHey = greet('Hey!');
greeterHey('Jonas.'); //  greeterHey -> is actually the functon behind return
greeterHey('Steven.');



RETURN STATEMENT
________________

The return statement stops the execution of a function and will not further continue the function.

NOTE: if we wanna use console.log(); inside of the function -> then it has to be BEFORE return

                
         return;  
         
         or

         return = 0;  Can also have a value
         
         
    function getRectArea(width, height) {
    if (width > 0 && height > 0) {
    console.log(getRectArea);
    return width * height;
    }
    return 0;
    }

    console.log(getRectArea(3, 4));
    // expected output: 12

    console.log(getRectArea(-3, 4));
    // expected output: 0
    
    
    
Redirect:

 if (err) {
      return res.redirect('/reset');  ---> This Line
    }
    
    

FUNCTION TYPES
______________

// used by personal preferences -> but bouth has to be known

// function type 1 -> function declaration
//               'Parameter'
function calcAge1(birthYear) {
  return 2037 - birthYear;
};
//     'Argument'
const age1 = calcAge1(1991);
console.log(age1);



// function type 2 -> function expression (expression produces values)
const calcAge2 = function(birthYear) {
  return 2037 - birthYear;
};

const age2 = calcAge2(1991);
console.log(age1, age2);


// function type 3 -> arrow functions
const calcAge3 = birthYear => 2037 - birthYear;
const age3 = calcAge3(1991);
console.log(age3);


// Example
const yearsUntilRetirement = (birthYear, firstname) => {
  const age = 2037 - birthYear;
  const retirement = 65 - age;
  // return retirement;
  return `${firstname} retires in ${retirement} years.`;
};

console.log(yearsUntilRetirement(1991, 'Jonas'));
console.log(yearsUntilRetirement(1980, 'Bob'));



Calling a function inside of another function
_________________________________________________

// first maschine is preparing stuff for the second maschine
function cutFruitIntoSmallPieces(fruit) {
  return fruit * 4;           // cutting into 4 pieces
};


function fruitProcessor(apples, oranges) {
  const applePieces = cutFruitIntoSmallPieces(apples);  // calling a function into another function
  const orangesPieces = cutFruitIntoSmallPieces(oranges);

  const juice = `Juice with ${applePieces} apple pieces and ${orangesPieces} orange pieces.`;
  return juice; // the result of executing the function
};
                     // CUTTING 2 apples and 3 oranges
console.log(fruitProcessor(2, 3));



(method??)
slice                 var name = Tobias;
                      name.slice(0,1);  -> from 0 to 1 BUT not including charakter at 1
                      
// slicing at 140 charakters

var sliceAt140 = 'hahhhhlloossskssksskshjdhsjhssdjssshajshdkjahsdggahdgjasgjdgsahhdgahsdghasjgdjshagjsahhajshdkasshjfhjkdhfassssssjhjshjkahsjhdajshdsajdhadgajdgakjsgdasgdsagdkjgjsajdgasjdgsajdgsajdgasjdgajsdgkaskskksksksdgssssssss';
var sliceAt140 = sliceAt140.slice(0,140);
console.log(sliceAt140.length);
console.log(sliceAt140);                    


// First Letter Big and all others small
var myName = 'toBIaS';
var myName =  myName.slice(0,1).toUpperCase() + myName.slice(1, myName.length).toLowerCase();
console.log(myName);



ARROW FUNCTION
______________

SYNTAX:
FAB: const foo = () => {}
                    â¬†ï¸
            return statement

const foo = (a) => {
console.log(a)
return a + 1
};

"Wenn du Ã¼ber mehrere Zeilen schreibst, ist das ein Block Statement und du musst return machen."


NOTE: NEVER use arrow functions as a method!


fetch(url)
  .then(res => res.json())
  .then(json => console.log(json));
  
 
 // thats the same without an arrow function
.attr('fill', function(data){return d.fill;}

// as arrow function
.attr('fill', data => data.fill)



How PRIMITIVES and OBJECTS work in the context of FUNCTIONS
___________________________________________________________

lektion 129  nicht kapiert



CALLBACK FUNCTIONS
__________________

.....



CALL & APPLY & BIND (FUNCTION) METHODS
______________________________________

CALL() METHOD
_____________

https://blog.bitsrc.io/understanding-call-bind-and-apply-methods-in-javascript-33dbf3217be


The call method sets the this inside the function and immediately executes that function.

The difference between call() and bind() is that the call() sets the this keyword and executes the function immediately and it does not create a new copy of the function, while the bind() creates a copy of that function and sets the this keyword.

SYNTAX:
function.call(thisArg, arg1, agr2, ...)


const lufthansa = {
  airline: 'Lufthansa',
  iataCode: 'LH',
  bookings: [],
  // book(flightNum, name) {}  // alternative syntax
  book(flightNum, name) {
    // book: function (flightNum, name) {
    // !!! 'to get the name propertie from the OBJECT -> we must use the -> this. keyword';
    console.log(
      `${name} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}`
    );
    // we "push" it into the bookings array!
    this.bookings.push({ flight: `${this.iataCode}${flightNum}`, name });
  },
};

lufthansa.book(239, 'Jonas Schmedtmann');
lufthansa.book(164, 'Mia Johnson');
console.log(lufthansa);

const eurowings = {
  airline: 'Eurowings',
  iataCode: 'EW',
  bookings: [],
  // we dont write the book function again! (bad practice) -> we just take the "method" / function from above and store it in a "external function"
  // we create a new function called book first, ...
  //           // (thats possible cause js has first class functions)
};
const bookFunction = lufthansa.book;
// we need to tell js explicitly which object we want to ?change?

//              //the first argument is -> what we want the this keyword TO POINT TO
//    // the call method will call the bookFunction function -> with the this keyword, set to eurowings
bookFunction.call(eurowings, 23, 'Sarah Williams');
console.log(eurowings);
bookFunction.call(lufthansa, 643, 'Paul Fender');
console.log(lufthansa);



APPLY METHOD (not really used)
____________

The apply() method is similar to call(). The difference is that the apply() method accepts an array of arguments instead of comma separated values.

SYNTAX:
function.apply(thisArg, [argumentsArr])


                                                  // we can just use the spread operator
cause, instead of using apply -> we cann use .call(...data)


does the same -> only difference is , does not receive a list of arguments -> it take an array of all the arguments

// Apply method
const flightData = [583, 'George Cooper'];
bookFunction.apply(eurowings, flightData);
console.log(eurowings);

// its the same with the call method and the spread operator
bookFunction.call(eurowings, ...flightData);



BIND() METHOD
_____________

lecture 134 (difficult)

The bind method creates a new function and sets the this keyword to the specified object

Syntax:
function.bind(thisArg, optionalArguments)


For example:

Letâ€™s suppose we have two person objects.

const john = {
  name: 'John',
  age: 24,
};
const jane = {
  name: 'Jane',
  age: 22,
};
Letâ€™s add a greeting function:

function greeting() {
  console.log(`Hi, I am ${this.name} and I am ${this.age} years old`);
}
We can use the bind method on the greeting function to bind the this keyword to john and jane objects. For example:

const greetingJohn = greeting.bind(john);
// Hi, I am John and I am 24 years old
greetingJohn();
const greetingJane = greeting.bind(jane);
// Hi, I am Jane and I am 22 years old
greetingJane();
Here greeting.bind(john) creates a new function with this set to john object, which we then assign to greetingJohn variable. Similarly for greetingJane.



// bind method
const bookEW = bookFunction.bind(eurowings);
const bookLH = bookFunction.bind(lufthansa);
bookEW(23, 'Steven Williams');
bookLH(524, 'Melissa Schmidt');

// all the arguments will be set automatically now
//                                         // arguments
const bookEW68 = bookFunction.bind(eurowings, 68);
bookEW68('Jonas Schmedtmann');
bookEW68('Martha Cooper');

// together with event listeners
lufthansa.planes = 300; // amout of planes they have lets say
lufthansa.buyPlane = function () {
  console.log(this);
  this.planes++; // takes the current number of planes and increses it by one, if we click the button "buy new plane"
  console.log(this.planes);
};
document
  .querySelector('.buy')
  .addEventListener('click', lufthansa.buyPlane.bind(lufthansa));
console.log(lufthansa.planes);



IIFE  -  IMMEDIATLY INVOKED FUNCTION EXPRESSION
_______________________________________________

If we wanna execute a function just ONCE
IIFE Is a function which disappears when its executed once and then never again

For ASYNC await is this as well important


this pattern called IIFE:

(function () {
  console.log('This will just run once');
})();
  â¬†ï¸
  we immediatly call the function here

NOTE: we trick JS a lil bit to avaid the reference err -> we wrap the function in () 



CLOSURES
________

NOTE: to fully understand closures, its neccessary to understand -> execution context, the call stack & sculpt chain
      -> closures brings all these conceps kind of together!
      

  

          OPERATORS
          _________

NOTE: OTHER OPERATORS to find around line 1000


// Assignment Operators          
let x += 10;  // x = x + 10    
x *= 4;       // x = x * 40 
x++;          // x = x + 1
x--;          // x = x - 1
          

// Comparison Operators
let x = 10;
let y = 5;
x > y;    // true
x < y;    // false



OPERATOR PRECEDENCE in JS
_________________________

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
-> scroll down to the table ->

________________________________________________________________________________
Precedence	Operator type	Associativity	Individual operators
18	Grouping	n/a	( â€¦ )
...
...
...


Math Operators will be executed before coparison operators for example

-> thats what we see in this table, but we dont have to know/remind all



EQUALITY OPERATORS
__________________

== vs. ===          (returns true or false value)

=== exactly         (actually always use this!)
==                  (actually never use this)

=== (does not type coersion)            '18' + 18           -> false
==  (does type coersion)                '18' + 18           -> true


!== NOT equal




          NUMBERS
          _______

Math.floor rounds down, 
Math. Ceiling rounds up,
Math. Trunc(ate) rounds towards zero


Operators:

......
......
......


Create a Random Number:

(Math.floor(Math.random()*100) + d.properties.mag))

Math.floor():
static method always rounds down and returns the largest integer less than or equal to a given number.


Math.trunc():
....



2 ** 3 means 2 * 2 * 2 = 8


Math.abs()
The math. abs() function is used to return the absolute value in JS. It negates the native sign of a number and returns the relevant positive value.

// movements on a bank accound example
const movements = [100, 450, -400, 3000, -650, -130, 70, 1300];

for (const movement of movements) {
  if (movement > 0) {
    console.log(`You deposit ${movement}`);
  } else {
    console.log(`You withdrew ${Math.abs(movement)}`);
  }



          TEMPLATE LITERALS `` (ES6)
          __________________________
                    
NOTE: in Template Literals we can just use EXPRESSIONS ! NO Statements!
          
 
We can write it like a Sentence, and just have to put in the ` ${var} ....   ` 
or just writing a normal sentence/ string with ``is also possible:

-> console.log(`This is a sentence written with just template literals`);


const firstName = 'Jonas';
const job = 'teacher';
const birthYear = 1991;
const year = 2037;


const jonasNEW = `Iam ${firstName}, a ${year - birthYear} year old ${job}!`


NOTE: Thats the old way ->

const jonas = 'Iam' + firstName + ', a ' + (year - birthYear) + ' years old ' + job + '!';




          IF and ELSE STATEMENTS (for taking decisions)
          ______________________

CONDITIONAL OPERATORS:
      
? is a if statement ,  : is a else statement in a single line

const age = 23;

age >= 18 ? console.log('You can drink alcohol') : console.log('Youre have to drink water instead');
//
const type = move > 0 ? 'deposit' : 'withdrawal';



BASIC BOOLEONS LOGIC:

&& AND                      when  A and B is true -> the whole operation becomes TRUE
|| OR                       when  A  or B is true -> the whole operation becomes TRUE
!A  NOT or the Opposite
!== NOT equal                 


Syntax:

    condition is always a booleon
if (condition) {                        // => Initial condition
} else if (condition) {                
} else if (condition) {                 // that are all different `conditions
} else {                                // !!! NO conditon here!
}


NO ->  ;  <- at the end of an if statement!


const age = 14;

   //condition
if (age >= 18) {  // if its true
  console.log('Sarah can make a driving licence ðŸš—');
} else {          // if its false
  const yearsLeft = 18 - age;
  console.log(`Sarah is nor old enough to make a car license! wait another ${yearsLeft} years!`)
}



NOTE: when we have more than 5 statements, its recommended to use then a -> SWITCH statement



SWITCH STATEMENTS
_________________

to compare one value to multiple different options for example


NOTE: SWITCH Statements a actually doing the same like if else statements -> we decide which one we prefer to use 



const day = 'monday';

switch (day) {
     case 'monday':  //  day === 'monday';
          console.log('...');
          break;
     case 'tuesday':
          console.log('...');
          break;
     case 'wednesday':                                   // we can use more cases to do the same
     case 'thursday':
          console.log('...');
          break;
       default:                                          // to finish we CAN set a default -> if all other cases fail   // like an else block
          console.log('Not a valid ...');
}




NOTE:
//any var inside the "code blocks" will not be accessable OUTSIDE of a "code block"


const birthyear = 1998;

let century;  // thats OUTSIDE
if (birthyear <= 2000) {        //
  century = '20 century';       // thats a "code block" inside the {}
} else {                        //
  century = '21 century';       //
};                              // thats a "code block" inside the {}

//any var inside the "code blocks" will not be accessable OUTSIDE of a "code block"
console.log(century);         // not accessable!
// -> century has to be declared OUTSIDE




          STATEMENTS AND EXPRESSIONS (the differences)
          __________________________
                    
An EXPRESSION produces a value -> like: 3 * 4 = 12; // 3 * 4 is an expression and 12 is an value 

An STATEMENT is like a bigger peace of code -> which isnt produce a value
          
          
         

          TRUTHY FALSY
          ____________

The Concept:
          
5 falsy values: 0, '', undefined, NULL, NaN       ->        will become false, when we convert into a booleon

console.log(Booleon(0));                ->        false     falsy
console.log(Booleon(undefined));        ->        false     falsy
console.log(Booleon('Jonas));           ->        true      truthy values
console.log(Booleon({}));               ->        true      truthy values
console.log(Booleon(''));               ->        false     falsy


        

          LOOPS 
          _____
         
FAB: bei for loops hat man ja meistens eine menge
     while nutzt man, solange ein "zustand" noch nicht erreicht ist und den erst herstellen muss


for loop
________

i is just a long used counter name

   (CONDITION)
    Start End   Change
      â†“    â†“    â†“ 
for (i=0; i<5; i++;) {
  // do something
}

for (let i=0; i<5; i++;) {
  console.log(i);
}

// for loop keeps running as long as the condition is TRUE
           (CONDITION)
for(let rep = 1; rep <= 10; rep++) {
console.log(`Lifting wheight repetion ${rep} ðŸ‹ï¸â€â™‚ï¸`);
}



looping and reading elements out of an array
____________________________________________

const jonas = [
'Jonas',
'Schmedtmann',
'2037 - 1991',
'teacher',
[Michael, Peter, Steven]
];

// console.log(jonas[0]);
// console.log(jonas[1]); 
// ...
// console.log(jonas[4]);
// console.log(jonas[5]); // 5 does NOT exist -> the CONDITION ends here

                  (dynamicly lenght of the loop)
for (let i=0; i < jonas.lenght; i++) {
console.log(jonas[i]);
}


for of loop
___________

for (const item of menu) console.log(item);
"its FOR the item OF the menu"

GETTING THE INDEX (is not so easy here)

for (const item of menu.entries()) {
console.log(item);
};



looping through the birthyears and creating the ages array
__________________________________________________________

const birthyears = [1997, 2010, 2001, 1969, 1953];
const ages = [];

for (i = 0; i < birstyears.lenght; i++) {
ages.push(2023 - birthyears[i]);
};

console.log(ages);          -> (5) [26, 13, 22, 54, 60]



important for loop STATEMENTS -> continue & break (NOT THAT IMPORTANT)
_________________________________________________

continue to exist the current iteration(repetition) of the loop AND CONTINUE to the next one
break terminates(stops) the whole loop


for (i = 0; i < birstyears.lenght; i++) {
if (birthyears < 50) continue;......  needs correction
};


looping BACKWARDS
_________________

actually we just use i-- instead of i++

->                  and - 1 is important


for (let i = var.length - 1; i >= 0; i--) {
console.log(var[i]);
}



looping inside of a loop
________________________

for (let exercise = 1; exercise < 4; exercise++) {
console.log(`---STARTING EXERCISE--- ${exercise}`);

          for (let rep = 1; rep < 6; rep++) {                    // inner loop
          console.log(`Lifting weights repetition ${rep}ðŸ‹ï¸â€â™‚ï¸`);
          }
}



while loop
__________

while = is checking a condition -> infinite loop until it turns from true to false -> will run while the condition is true
-> in a while loop we can ONLY specific a CONDITION
-> perfect to use if DONT KNOW how many iteration we have

var i = 1;

      (CONDITION) ONLY    
while (i<2) {
  console.log(i);
  i++;
}


EXAMPLE:

for (let rep = 1; rep < 10; rep++) {                
console.log(`Lifting weights repetition ${rep}ðŸ‹ï¸â€â™‚ï¸`);
}

let rep = 1;
while (rep < 10) {
console.log(`Lifting weights repetition ${rep}ðŸ‹ï¸â€â™‚ï¸`);
rep++;
};


BEST EXAMPLE: 

let dice = Math.trunk(Math.random()*6) + 1;

while (dice !== 6) {
console.log(`You rolled a ${dice}`);
dice = Math.trunk(Math.random()*6) + 1;          -> IMPORTANT, cause without this its an infinite loop and will crash the browser!
if (dice === 6) console.log('Loop is about to end, cause you rolled a 6');
}




          ARRAYS
          ______

TOP ZUSAMMENFASSUNG @ Lektion 165

arrays are objects, thats why they have methods too


//     i = index: 0, 1, 2    // i is the positon of the item in the array // i is just a long used name for the index position
const dataArray = [4, 15, 34];  // array without objects


// reassigning ONE value -> is still possible with const -> because its possible in arrays
dataArray[1] = 22;  // -> [4, 22, 34];


              | we need the new keyword to use an array function      
const years = new Array(1991, 1994, 2008, 2020);  // array function

// array with objects inside of the array
var dataArray = [
  {width: 25, height: 4, fill: 'red'},
  {width: 25, height: 15, fill: 'red'},
  {width: 25, height: 34, fill: 'red'}
];



PRO TIPP:

to get the last element of an array -> where we dont know the length of the array:

-> console.log(data[data.length -1]);
->  or     ...(data.at(-1))


to get the length of an array:

-> console.log(data.length);


NOTE: 

"Nested ARRAYS" are arrays inside of an array -> const nestedArray = [1, 2 [5, 6]];



ARRAY METHODS
_____________

// Add Elements
array.push      -> adds elements to the end of an array
.unshift   -> adds elements to the beginning of an array

// Remove Elements
array.pop       -> removes the last element of an array          // gives us back the value of the removed element
.shift     -> removes elements to the beginning of an array


// SORT Elements = sorting the elements of the array
const array = [3, 2, 1];
console.log(array.sort());

// FILL = is filling up specific elements with wanted data/values
const array2 = [4, 3, 2, 1];
// console.log(array.fill('ðŸŒ…', 0));
// console.log(array.fill('ðŸŒ…')); // alternative
console.log(array2.fill('ðŸŒ…', 1)); // -> all elements starting at = index 1, will be filled up with the ðŸŒ…
// console.log(array.fill('ðŸŒ…', 2)); // -> all elements starting at = index 2, will be filled up with the ðŸŒ…

// // creating an array with same elements repeated multiple times
const a = Array(5).fill(4);
console.log(a);


// TRIM array = to cut down the array at a specific position
const a = [5, 6, 7, 8, 9];
a.length = 2;
console.log(a); -> [5, 6]

// SLICE (creates a new array)
let arr = ['a', 'b', 'c', 'd', 'e', 'f'];
console.log(arr.slice(2));
console.log(arr.slice(2, 4)); // the end-parameter element, is NOT included in the output!
console.log(arr.slice(-3));
console.log(arr.slice(-1)); // last element of the array
console.log(arr.slice(1, -2));

// // to create an copy of the array
console.log(arr.slice());
console.log([...arr]); // alternative

// SPLICE (mutates the original array) (overwrites them)
-> to delete an element from the array
-> we need the index for the splice method
// console.log(arr.splice(2));
arr.splice(-1);
console.log(arr); // USEFUL

NOTE:
we can also use a second parameter for splice, but this one works different than the second parameter of slice


// REVERSE (mutates the original array)
arr = ['a', 'b', 'c', 'd', 'e', 'f'];
const arr2 = ['j', 'i', 'g', 'k', 'h'];
console.log(arr2.reverse());

// CONCAT ("merge")
const concat = arr.concat(arr2); // NO MUTATE
console.log(concat);
console.log([...arr, ...arr2]); // same result -> but NO MUTATE

// JOIN
console.log(concat.join('-'));

// INDEXOF (returns the index of the element)    LOOKS FOR EQUALITY
console.log(data.indexOf(value));

// INCLUDES (to check if there is an specific element with strict value in the array)
-> gives us a booleon

console.log(data.includes(value));

-> useful for 

if (data.includes(value)) {
 console.log('Data was found!');
console.log(value); -> booleon
};

// SOME (kind of like the includes method) (BUT)     LOOKS FOR A CONDITION
-> gives us a booleon -> is checking the whole arr -> if there is any value fits the conditions, than its true

const arr = [100, 200, 300, -100, -200, -300];
const test = arr.some(function(foo) {
return foo > 0;
});
console.log(test);

// EVERY 
"if EVERY element passes the condition -> only then the every methods becomes true"

// FLAT ("flattens the array")
-> good for nested array for example (but just goes one level deep in the nested arrays)
const arr = [[1, 2, 3], 4, 5, [6, 7]]
console.log(arr.flat());

-> to go 2 levels deep
const arrDeep = [[1, 2, 3], 4, 5, [6, 7]]
console.log(arrDeep.flat(2));

// AT (ES6) (optional)
const arrayAT = [32, 11, 64];
console.log(arrayAT[0]); // traditional way
console.log(arrayAT.at(0)); // at method - like we speak "element at position 0"
console.log(arrayAT.at(-1));
console.log('jonas'.at(0));
console.log('jonas'.at(-1));

// FIND (to retrieve one element of an array -> based on a condition)
 "is to find exactly one element which satisfy the condition"

- loops over the array -> but the it makes something different => retrieve one element of an array
-> gives us just ONE element back and not an array
- only return the FIRST element which satisfy the condition 

// FINDINDEX (returns just the index of the found element (not the element itself!) in the array, which fits the condition)

// SORT (sorts from a to z) -> mutates the orginal array
// with strings
const owners = ['Jonas', 'Zach', 'Adam', 'Martha'];
console.log(owners.sort());
console.log(owners);


NOTE: sort is by default for sorting strings
-> we need a callback function to use it with numbers


// sorting numbers
const movements = [100, -200, 300, -550, 70]; 

console.log(movements);
console.log('______');

NOTE: when we sort numbers, we need a callback function
-> the callback function needs 2 arguments like a, b


// DIE REGEL IST: "BEIM POSITIVEN RETURN WERT -> KOMMT B vor A"
// "if we return less than 0 -> than a will be sorted before b"
// return < 0 (negativ value)  -> A, B => (keep order)
// DIE REGEL IST: "BEIM NEGATIVEN RETURN WERT -> KOMMT A vor B"
// "if we return greater than 0 -> than b will be sorted before a"
// return > 0  (positive) -> B, A => (switch order)

// aufsteigende reihenfolge  -3, -2, -1, 1, 2, 3  => das bedeutet, dass a immer kleiner ist als b === a < b
movements.sort(function (a, b) {
  // DIE REGEL IST: "BEIM POSITIVEN RETURN WERT -> KOMMT B vor A"
  if (a > b) return 1; // return > 0 (positive) -> B, A
  // DIE REGEL IST: "BEIM NEGATIVEN RETURN WERT -> KOMMT A vor B"
  if (a < b) return -1; // return < 0 (negativ value) -> A, B
});
console.log(movements);

// alternative (nicht verstanden wie es funktioniert) VIEL KÃœRZER
movements.sort(function (a, b) {
  return a - b;
});
console.log(movements);


// absteigende reihenfolge  3, 2, 1, -1, -2, -3   => das bedeutet, dass a immer grÃ¶ÃŸer ist als b === a > b
movements.sort(function (a, b) {
  if (a > b) return -1;
  if (a < b) return 1;
});
console.log(movements);

// alternative (nicht verstanden wie es funktioniert) VIEL KÃœRZER
movements.sort(function (a, b) {
  return b - a;
});
console.log(movements);



FROM METHOD - GENERATING A NEW ARRAY ATOMATICLY
_______________________________________________

"we can create arrays FROM other things"

Merksatz: create a new array from(with) a length of

- we have to define 2 arguments, but the first argument (= currentElement) can be empty _ , cause we dont use it
- we actually just need the index

const z = Array.from({ length: 8 }, function (_, i) {
  return i + 1;
});
console.log(z);


// generating an array to a specific length, filled up with the same value
const y = Array.from({ length: 8 }, function () {
  return 8; //   -> filling up value
});
console.log(y);


Iterables
_________

What are the list of iterables in JavaScript?
String , Array , TypedArray , Map and Set are all built-in iterables, because their prototype objects all have a Symbol.

-> they can be converted to real arrays -> using  Array.from()



LOOPING ARRAYS -> forEach
_________________________

// movements on a bank accound example
const movements = [100, 450, -400, 3000, -650, -130, 70, 1300];
// for of loop
// for (const movement of movements) {
// // .entries returns the index, and the value
for (const [i, movement] of movements.entries()) {
  if (movement > 0) {
    console.log(`Movement ${i + 1}: You deposit ${movement}`);
  } else {
    console.log(`Movement ${i + 1}: You withdrew ${Math.abs(movement)}`);
  }
}
// forEach is a higher order function -> which requires a callback function
// forEach loop
console.log('----- FOREACH -----');
// NOTE: forEach has access to the current element, the index, and the array itself
//              // Callback function
movements.forEach(function (movement, index, array) {
  // the ORDER here is crutial: 1. element, 2. index, 3. array (we dont need everything if dont want)
  if (movement > 0) {
    console.log(`Movement ${index + 1}: You deposit ${movement}`);
  } else {
    console.log(`Movement ${index + 1}: You withdrew ${Math.abs(movement)}`);
  }
});



DESTRUCTURING ARRAYS
____________________

const arr = [1, 2, 3];

const a = arr[0];
const b = arr[1];
const c = arr[2];

const [x, y, z] = arr;  <- thats the deconstruction of the array !THATS NOT AN ARRAY, just the reassignment
console.log(x, y, z);



EXAMPLE:

const restaurant = {
  name: 'Classico Italiano',
  location: 'Via Angelo Tavanti 23, Firenze, Italy',
  categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],
  starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
  mainMenu: ['Pizza', 'Pasta', 'Risotto']
};

const [first, second] = restaurants.categories;  <- thats the deconstruction of the array !THATS NOT AN ARRAY, just the reassignment
console.log(first, second);



IF WE WANT THE FIRST AND THIRD ELEMENT or what else HOW TO:

we have do do a "gap"
             â¬‡
const [first, , second] = restaurants.categories;  -> now the second becomes the third ELEMENT
console.log(first, second);



NESTED DESTRUCTERING
____________________

const nestedArray = [1, 3 [5, 6]];
const [i, , [j, k]] = nestedArray;      -> we do destructoring inside of destructoring
console.log(i, j, k);



SWITCHING ELEMENTS
__________________

let [main, , secondary] = restaurants.categories;

[main, secondary] = [secondary, main]
console.log(main, secondary);




METHODS -> FOR DATA TRANSFORMATIONS
___________________________________

.map
similar as the forEach method
-> for looping
-> creates a NEW array
-> we CAN ADD more methods, cause we get back a an arr

.filter
Like: value > 2
      [3, 1, 4, 3, 2] -> [3, 4, 3]
-> returns a new array
-> we CAN ADD more methods, cause we get back a an arr

.reduce
-> reduces all array elements to ONE SINGLE value
-> gives us NO new array, just the reduced single value
Like: value > 2
      [3, 1, 4, 3, 2] -> 13

-> reduce gives us a value -> we can NOT ADD more methods to a value


-> we can chain this methods together or after another
-> at least, dont over do
-> its bad practice, to mutate the underlying original array (with the splice or reverse method for example) 




          OBJECTS
          _______
                    
For Key Value PAIRS

- the order of elements does NOT matter
          
const object = {
  num: 5          // => thats a PROPERTIE (inside of the object) with a VALUE === Key value PAIR
};     

console.log(object.num);    //  . -> access PROPERTIE inside of an object
          

const jonas = {
  firstname: 'jonas',
  name: 'schmidt',
  age: 2022 - 1991,                     // can hold expressions!
  friends: ['tom', 'bob', 'adam']       // can hold arrays
};



DESTRUCTORING OBJECTS
_____________________

- the order of elements does NOT matter
- really useful for api calls

const {name, friends, age} = jonas;           -> this is creating three brandnew variables based in this object
console.log(name, friends, age);



ADDING PROPERTIES
_________________

jonas.location = 'portugal';

console.log(jonas);


       
HOW TO GET SPECIFIC DATA FROM AN OBJECT
_______________________________________

-> with the . notation                  // for fixed properties usage

console.log(jonas.name);      

or

with [] notation

console.log(jonas[]);



USING FUNCTIONS INSIDE OF AN OBJECT
___________________________________

const jonas = {
  firstname: 'jonas',
  name: 'schmidt',
  birthYear: 1989,
  age: 2022 - 1989,                     // can hold expressions!
  friends: ['tom', 'bob', 'adam'],       // can hold arrays
  // syntax for a function inside of an object
  calcAge8: function(birthYear) {
    return 2037 - birthYear;
  }

};

console.log(jonas.calcAge(1989));




           SETS (=DATA STRUCTURE) NOT THAT USEFUL
          _______________________

a set is a collection of unique values (or when we need to use unique values)

the order of the elements in a set is irrelevant

set are not to replace arrays at all


const ordersSet = new Set (['Pasta', 'Pizza', 'Risotto', 'Pasta', 'Pizza']);
console.log(ordersSet);          -> Set(3) {'Pasta', 'Risotto', 'Pizza'}          -> All duplicates are GONE

NOTE: its not an array now - its a SET !

      we CANT use INDEX! (not neccesarry cause all elements are unique, also there is no need to get data out of a set)



to get the length of a set, we have to use .size instead of .length!

to know if there is a certain element in the set -> we use .has  (.includes method for arrays) 

add new elements to a set -> .add

to delete a elements -> .delete



                    has is actually amethod
console.log(ordersSet.has('Pizza'));          -> true
console.log(ordersSet.has('Buritto'));        -> false




           MAPS (= DATA STRUCTURE) RLY USEFUL
          _______________________

a map is a data structure that we can use to map values to keys. So, just like an object data is stored in key value pairs in maps.

Now, the big DIFFERENCE between objects and maps is that in maps, the keys can have ANY TYPE and this can be huge. So, in objects, the keys are basically always strings. But in maps, we can have any type of key. (It could even be objects, or arrays, or other maps.)



1 => 'Firence, Italy'                    FOR UNDEERSTANDING: 1 will  BE MAPPED  to Firence, Italy


EXAMPLE:

const rest = new MAP();

        KEY,      VALUE
rest.set(1, 'Firence, Italy');        
console.log(rest);                    -> MAP(1) {1 => "Firence, Italy"}
console.log(rest.get(1));             -> Firence, Italy


NOTE: using booleons as maps keys is not that easy


METHODS:

.set
.get
.has
.delete(1) (deletes one entry)
.size
.clear() (clears everything)




----------OTHER OPERATORS---------------
________________________________________


          SPREAD OPERATOR
          _______________

- the spread operator basically EXPAND an array into all its elements

- so basically unpacking all the array elements at one

NOTE: spread operator does NOT work inside/with template lterals!   ` ${var} ....   ` 


->

... to expand the array to all individual elements

- its like taking out all the elements of the array!

const arr = [7, 8, 9];
const newArray = [1, 2, ...arr]; -> using the spread operator
console.log(newArray);        -> [1, 2, 7, 8, 9]
console.log(...newArr);       -> 1 2 7 8 9


NICE EXAMPLE: merge two arrays + spread operator

const x = [4, 5];
const y = [6, 7];
const z = [...x, ...y];
console.log(z); -> (4)Â [4, 5, 6, 7]



EXPANDING THE ARRAY
___________________

NOTE: we are building a new array! (we dont change the old one)

const expandedArray = [...newArray, 12];
console.log(expandedArray);   -> [1, 2, 7, 8, 9, 12]


Strings:
const name = `Jonas`;
const letters = [...name, " ", "T"];
console.log(letters);         -> ["J", "o", "n", "a", "s", " ", "T"]



ES6
___

const arr = [1, 2, 3];
arr(arr[0], arr[1], arr[2]);  -> old way
arr(...arr);                  -> ALWAYS use this  (ES6)




          REST PATTERN
          ____________
 
- with the rest operator we COMPRESS 

- the rest patterm is really the opposite of the spread operator but with the same syntax! JUST ON THE LEFT SIDE OF =
 
- the rest pattern uses the exact same syntax however, to collect multiple elements and condense them into an array.


REST, because on the LEFT side of the =
                    
                has to be always at the end of the array   (and so it takes all the rest elements)
                   â¬‡ï¸
const [a, b, ...others] = [1, 2, 3, 4, 5];
console.log(a, b, others);    -> 1 2 [3, 4, 5]



USEFUL EXAMPLE:
_______________

const restaurant = {
openingHours = {
  thur: {
   open: 12,
   close: 22
    },
  fri: {
   open: 12,
   close: 24
    },
  sun: {
   open: 14,
   close: 24
  }
};


//for Objects
const { sun, ...weekdays } = restaurant.openingHours;       
console.log(weekdays);        -> {thur: {...}, fri: {...}}




          AND & OR OPERATOR (&& and ||) for Short Circuiting (Evaluation)
          _______________________________________________________________  
          
NOTE:

DONT replace all your if statements with the AND or the OR operators!
 
 
Short Circuiting (Evaluation) : means -> that if the first value is a truthy value, it will immediately return that first value.

OR Operator
___________
          
// Use ANY data type, return ANY data type, short circuting
console.log(3 || 'Jonas');    -> 3                -> short circuiting means that if the first value is a truthy value, it will immediately return that first value. (if the first operand is truthy here in the OR operator, then the other operand will not even be evaluated.)
console.log('' || 'Jonas')    -> Jonas            -> '' = falsy  -> because of the first value which is falsy, the second velue will be executed cause this one is truthy
          
          
          
AND Operator
____________

the AND operator works in the exact opposite way of the OR operator.

console.log('Hello', 23, null, 'Jonas');  -> null will be returned -> null is a falsy value and therefore evaluation no longer needs to continue because at this point, the WHOLE result of the end operation is gonna be false anyway.




          NULLISH COALESCING OPERATOR ??
          ______________________________

works almost the same like the or operator

works with nullish values instead of falsy values -> nullish values are: null and undefined (NOT 0 or '')

works also for methods and arrays




          OPTIONAL CHAINING ?.
          ____________________

- works also for methods and arrays

// normal  way
if (restaurant.openingHours && restaurant.openingHours.mon)
          console.log(restaurant.openingHours.mon.open);          -> error



// with optional chaining

only if monday exists, the this open propertie will be read -> when not -> immediately undefined will be returned

only if the propertie which is before this ?.

console.log(restaurant.openingHours.mon?.open));          
console.log(restaurant.openingHours?.mon?.open));          -> if opening does not exists , then the mon propertie will not be read


THATS REALLY USEFUL TO PreveNT ALL KIND OF BUGS


// example
const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];

for(const day of days) {
   const open = restaurant.openingHours[day]?.open          -> we need to use the [] instead of . cause we use the VARIABLE NAME as the PROPERTIE NAME basically (the day is coming dynamicly from the days array!)
   console.log(`On ${day}, we open at ${open}`);            -> On mon we open at undefined          -> we dont want undefined SOLUTION is, to set adefault value
}                                                           -> On tue we open at 12


  -> we dont want undefined SOLUTION is, to set adefault value


 SOLUTION is to use optional chaining operator + nullish operator, working together


for(const day of days) {                         
   const open = restaurant.openingHours[day]?.open ??       
   console.log(`On ${day}, we open at ${open}`);            -> On mon we open a
}                                                           -> On tue we open at 12




          DOM (Manipulation) (lecture 185)
          __________________

https://www.w3schools.com/jsref/dom_obj_all.asp


DOM (API) = Is the INTERFACE (Schnittstelle) between JS and the BROWSER
    -> so we use the DOM to let JS interact with the BROWSER 
    -> the DOM cointains a ton of METHODS and PROPERTIES which we use to INTERACT with the DOM TREE

                                        METHODS                                                            PROPERTIES
    like:      (.querySelector() / .addEventlistener() / .createElement() /           .innerHTML / .textContent / .children / etc.... )
    = HTML Documents are REDERED IN and BY the BROWSER

- the dom is created -> by the code and creates a tree structure (the DOM)

- document is the highest rank in the tree structure -> serves as a entry point to the DOM



THE DOM TREE
____________


            DOCUMENT
               |
              HTML     (first child)
            |     |
           HEAD  BODY  (two childs)
           ..........
           etc...


which has parents and children and so one

- allows javascript to access html elements and css style to manipulate them



SELECT, CREATE & DELETE ELEMENTS in JS
______________________________________

methods:

console.log(document); // that not enough
console.log(document.documentElement); // -> this is, how we get ALL the elements from the document
console.log(document.head);
console.log(document.body);

document.querySelector('.header'); // we need the . (selector) to select the element
// querySelectorAll method gives us a NodeList -> didnt update itself if we delete an element live in the browser
const allSections = document.querySelectorAll('.section'); // we need the . (selector) to select the element
console.log(allSections);

document.getElementById('section-1');
// getElementsByTagName method gives us a HTMLColletion -> when the DOM changes, this is updating live = ("live-collection")
const allButtons = document.getElementsByTagName('button');
console.log(allButtons);

console.log(document.getElementsByClassName('btn'));



NOTE:

- syntax for changing css styles is different in DOM manipulation case
-> its always a string
-> and some names, like background-color -> is written camelCase now -> backgroundColor


    document.querySelector('.body').style.backgroundColor = 'green';
    document.querySelector('.number').style.width = '30rem';



OTHER EXAMPLES:


html file:
<script src="script.js"></script>   <!-- this has to be at the end of the file, because the body tags have to be readed first -->
 

app.js file:

// querySelector looks inside the whole document for a single item (element, class or id), h1 in this case
document.querySelector('h1').innerHTML = 'Good bye'; // works


NOTE:
when using querySelector and  querySelectorAll -> we have to use a selector -> .


// getElementsByClassName goes throw the whole document and looks for the elementS with a particular class
document.getElementsByClassName('item')[0].innerHTML = 'good';  // its Elements so an array!

// const container = document.getElementById('container');
document.getElementById('container').innerHTML = 'Tschau';

// getElementsByTagName goes throw the whole document and looks for the elementS with a particular tag
document.getElementsByTagName('li')[1].innerHTML = 'ok';    // its Elements so an array!



METHODS
_______

.toogle() 
aviable on the classList propertie
will add the class if its not there and remove the class if its already there


.prepend() 
The Element.prepend() method inserts a set of Node objects or string objects before the FIRST CHILD of the Element. String objects are inserted as equivalent Text nodes.

.apend()
The Element.append() method inserts a set of Node objects or string objects after the LAST CHILD of the Element. String objects are inserted as equivalent Text nodes.


NOTE:
the element is just inserted once, cause its a live element living in the DOM! -> it cannot be at multiple places a the same time (like a person..)

EXAMPLE:

// creating and inserting elements
const message = document.createElement('div'); // returns (creates) a DOM Element
message.classList.add('cookie-message');
// message.textContent = 'We use cookies for improved functionallity and analytics';
message.innerHTML =
  'We use cookies for improved functionallity and analytics. <button class="btn btn--close-cookie">Got it!</button>';

header.prepend(message); // -> we add our message to the header with prepend
header.append(message); // -> we add our message to the as last child with append
â¬†ï¸â¬†ï¸â¬†ï¸
THATS NOT POSSIBLE to be there two times , just ONCE !!!

.remove()




          EVENT LISTENERS
          _______________

// keyboard events (= global events)        // e is event
document.addEventListener('keydown', function (e) {
  console.log(e.key);
  // if the esc key is pressed and the modal is NOT contains the class of hidden -> then close the modal
  if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
    closeModal();
  }
});


NOTE: by default in HTML, a submit button is RELOADING the page (when the e is happening for sure)

to prevent this from happening ->

btn.addEventListener('click', function(e) { 
e.preventDefault();
});




          STRINGS
          _______

Strings are primitives
"boxing" makes it possible to use methods with strings as well (actually they dont have methods) -> JS converts it to objects via boxing

// STRINGS 121

const airline = 'TAP Air Portugal';
const plane = 'A320';

console.log(plane[0]);
console.log(plane[1]);
console.log(plane[2]);
console.log('A320'[0]); // alternative

console.log(airline.length);
console.log('A320'.length);



METHODS
_______
          
console.log(airline.indexOf('r')); // the first found r
console.log(airline.lastIndexOf('r')); // the last found r
console.log(airline.indexOf('Portugal')); // -> case sensitive

// slice
// hardcoded
console.log(airline.slice(4)); // returns a new string
console.log(airline.slice(4, 7)); // -> 7(end) (stops before reaching index number 7) - 4(beginning) = 3 => Air
console.log(airline.slice(1, -1)); // starts at 1 and cuts -1 charakter

// slice
//dynamic
// for the first word
console.log(airline.slice(0, airline.indexOf(' ')));
// for the last word
console.log(airline.slice(airline.lastIndexOf(' ') + 1));

// EXAMPLE (extracting parts from strings)
const checkMiddleSeat = function (seat) {
  // B and E are middle seats
  const s = seat.slice(-1);
  if (s === 'B' || s === 'E') console.log('You got the middleseat ðŸ‘©â€ðŸš€');
  else console.log('You got lucky ðŸ‘©â€ðŸŒ¾');
};

checkMiddleSeat('11B');
checkMiddleSeat('23C');
checkMiddleSeat('3E');



....(
UPPER & LOWER CASE METHODS
___________________________

console.log(airline.toLocaleLowerCase());
console.log('TAP Air Portugal'.toLocaleLowerCase()); // alternative

// Fix capitilization in Name
const passenger = 'toBiaS';
const passengerLower = passenger.toLowerCase();
console.log(passengerLower);
const passengerUpper = passenger.toUpperCase();
console.log(passengerUpper);

// we take the first lower Case letter and make it upper + we cut of the first letter -> and just took the rest
const passengerCorrect =
  passengerLower[0].toUpperCase() + passengerLower.slice(1);
console.log(passengerCorrect);

// comparing email
const email = 'hello@tobias.de';
const typedEmail = '  heLlO@toBIas.de'; // actually the email is correct, but NOT the capitalization

const lowerEmail = typedEmail.toLowerCase();


TRIM METHOD
___________

const trimmedEmail = lowerEmail.trim(); // trim METHOD to get of the empty spaces
console.log(trimmedEmail);

// same in short
const normalizedEmail = typedEmail.toLowerCase().trim();
console.log(normalizedEmail);

if (email === normalizedEmail) {
  console.log('Typed Email is correct');
} else {
  console.log('Typed Email is not correct');
}

)......



REPLACING
_________

// replacing (a part of strings)
const priceUSA = '188.97$';
const priceEU = priceUSA.replace('$', 'â‚¬').replace('.', ',');
console.log(priceEU);
//_________

const announcement = 'All passengers come to door 23 for Boarding.';
console.log(announcement.replace('door', 'gate'));


FOR TESTING BOOLEANS
____________________

const airplane = 'A320neo';
console.log(airplane.includes('A320'));
console.log(airplane.includes('Boing'));
console.log(airplane.startsWith('B'));
console.log(airplane.startsWith('A3'));


// Exercise
const checkBaggage = function (items) {
  const baggage = items.toLowerCase();

  if (baggage.includes('knife') || baggage.includes('gun')) {
    console.log('You are not allowed on board!');
  } else {
    console.log('Welcome on board');
  }
};

checkBaggage('I have a laptop, some Food and a pocked Knife.');
checkBaggage('Socks and camera.');
checkBaggage('Got some snacks and a gun for protection.');



SPLIT METHOD
____________

// allows us to split a string into multiple parts (on a devider string)
console.log('a+very+nice+string'.split('+'));          -> (4) ["a", "very", "nice", "string"]
console.log('Tobias Schumann'.split(' '));             -> (2) ["Tobias", "Schumann"]

// we can store directly in the variables if we want
const [firstName, lastName] = 'Tobias Schumann';
console.log(firstName, lastName);



JOIN METHOD
____________

- actually the opposite of split


const [firstName, lastName] = 'Tobias Schumann'.split(' '); // split is NECCESARY cause this splits the values in the [ ] and makes it possible to use them after

const newName = ['Mr.', firstName, lastName].join(' ');
console.log(newName);          -> Mr. Tobias Schumann



USEFUL EXERCISE:

// CAPITALIZATION
const capitalizedName = function (name) {
  const names = name.split(' ');
  const namesUpper = []; // EACH WORD will trouth the for loop -> stored into this array/ string???

  for (const n of names) {
    // a loop for EACH word we have to capilize
    namesUpper.push(n[0].toUpperCase() + n.slice(1)); // fist letter upper + the sliced rest put on
  }
  console.log(namesUpper.join(' ')); // joining all together with ' ' between the words
};

capitalizedName('jessica ann smith davis');          -> Jessica Ann Smith Davis



GETTING THE SAME LENGTH OF A STRING
___________________________________

- the idea is, that we get a string with the same length always automatically

lkke this: (thats what we want to have at the end)

++++++Go to Gate 23! * string has a length of 20 now
+++++++Go to Gate 8! * string has a length of 20 now
+++++Go to Gate 104! * string has a length of 20 now



///// code

// text right
const message = 'Go to Gate 23!';
console.log(message.padStart(20, '+') + ' * string has a length of 20 now');

const message2 = 'Go to Gate 8!';
console.log(message2.padStart(20, '+') + ' * string has a length of 20 now');

const message3 = 'Go to Gate 104!';
console.log(message3.padStart(20, '+') + ' * string has a length of 20 now');
console.log(message3.padStart(20, '+').length); // for testing -> all correct

//  text in the middle
console.log(message.padStart(25, '+').padEnd(35, '+'));
console.log(message2.padStart(25, '+').padEnd(35, '+'));
console.log(message3.padStart(25, '+').padEnd(35, '+'));

// text left
console.log(message.padEnd(35, '+'));
console.log(message2.padEnd(35, '+'));
console.log(message3.padEnd(35, '+'));


USEFUL
MASKING NUMBERS
_______________

//masking credit card numbers


NOTE: IF WE WANT TO CONVERT A NUMBER TO A STRING ->

const str = number + '';

-> when one of the operands of the plus sign is a string -> it will convert all the operands to a STRING


// masking a creditcardnumber    //(what we recive)
const maskingCreditCard = function (number) {
  const str = number + ''; // we have to convert the number to a string first
  const lastCharakterOfTheNumber = str.slice(-4);
  return lastCharakterOfTheNumber.padStart(str.length, '*');
};

console.log(maskingCreditCard(115500001000044525));    ->      **************4530
console.log(maskingCreditCard(644400002000074387));    ->      **************4400



CONVERTING A STRING INTO A NUMBER
_________________________________

const numberDepositAmount = parseFloat(depositAmount); // takes a string -> looks for "numbers" and converts into number -> "17,2" => 17.2
console.log(numberDepositAmount); -> 17.2



REPEATING A STRING
__________________

const messageDelayed = 'Bad weather, all departures delayed!...';
console.log(messageDelayed.repeat(3));

const planesWaiting = function (n) {
  console.log(`There are ${n} planes waiting in line ${'ðŸ›©ï¸'.repeat(n)}`);
};

planesWaiting(5);
planesWaiting(3);
planesWaiting(12);




          jQUERY
          ______

jQuery is a library for Javascript

https://developers.google.com/speed/libraries/



$() -> select one or all items


Event Listener:
- will be called whenever the specified event is delivered to the target
                                        .click
                                        .keypress
                                        .

element.addEventListener("click", function(){ alert("Hello World!"); });


// Eventlistener for keydown event

$(document).keydown(function(event) {
    $("h1").text(event.key);
    console.log(event.key);
});


Animations:
$().animate({})




          COUNTER
          _______  
      
const s = date.getSeconds();
const procent100 = 60;                                         // Wichtig und richtig
var currentPercentS = Math.floor(s / procent100 * 100);
console.log(s);
console.log(currentPercentS + "% of 1 Minute");


TIME IN REALTIME

include in html file ->

<script>
`use strict`;
function refreshTime() {
  const timeDisplay = document.getElementById("time");
  const dateString = new Date().toLocaleString();
  const formattedString = dateString.replace(", ", " - ");
  timeDisplay.textContent = formattedString;
}
  setInterval(refreshTime, 1000);
</script>


